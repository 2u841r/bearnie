---
import { cn } from '@/utils/cn';
import type { HTMLAttributes } from 'astro/types';

export interface Props extends HTMLAttributes<'div'> {}

const { class: className, ...props } = Astro.props;

const classes = cn(
  'flex h-full w-full flex-col overflow-hidden rounded-lg bg-popover text-popover-foreground',
  className
);
---

<div class={classes} data-command {...props}>
  <slot />
</div>

<script>
  import { generateId } from '@/utils/focus-trap';

  function initCommands() {
    document.querySelectorAll('[data-command]').forEach((command) => {
      if (command.hasAttribute('data-command-initialized')) return;
      command.setAttribute('data-command-initialized', 'true');

      const input = command.querySelector('[data-command-input]') as HTMLInputElement;
      const list = command.querySelector('[data-command-list]') as HTMLElement;
      const empty = command.querySelector('[data-command-empty]') as HTMLElement;
      const items = Array.from(command.querySelectorAll('[data-command-item]')) as HTMLElement[];
      const groups = command.querySelectorAll('[data-command-group]');

      // Generate IDs for ARIA relationships
      if (list && !list.id) {
        list.id = generateId('command-list');
      }

      // Generate IDs for items
      items.forEach((item, index) => {
        if (!item.id) {
          item.id = generateId(`command-item-${index}`);
        }
      });

      // Link input to list
      if (input && list) {
        input.setAttribute('aria-controls', list.id);
      }

      let selectedIndex = -1;

      // Filter items based on input
      const filterItems = () => {
        if (!input) return;
        
        const query = input.value.toLowerCase().trim();
        let visibleCount = 0;

        items.forEach((item) => {
          const text = item.textContent?.toLowerCase() || '';
          const matches = query === '' || text.includes(query);
          item.hidden = !matches;
          if (matches) visibleCount++;
        });

        // Hide empty groups
        groups.forEach((group) => {
          const groupItems = group.querySelectorAll('[data-command-item]');
          const hasVisibleItems = Array.from(groupItems).some(
            (item) => !(item as HTMLElement).hidden
          );
          (group as HTMLElement).hidden = !hasVisibleItems;
        });

        // Show/hide empty state
        if (empty) {
          empty.hidden = visibleCount > 0 || query === '';
        }

        // Reset selection
        selectedIndex = -1;
        updateSelection();
      };

      // Update visual selection and ARIA
      const updateSelection = () => {
        const visibleItems = items.filter((item) => !item.hidden);

        visibleItems.forEach((item, index) => {
          if (index === selectedIndex) {
            item.setAttribute('data-selected', 'true');
            item.setAttribute('aria-selected', 'true');
            item.scrollIntoView({ block: 'nearest' });
            // Set aria-activedescendant on input
            if (input) {
              input.setAttribute('aria-activedescendant', item.id);
            }
          } else {
            item.removeAttribute('data-selected');
            item.setAttribute('aria-selected', 'false');
          }
        });

        // Clear aria-activedescendant if nothing selected
        if (selectedIndex === -1 && input) {
          input.removeAttribute('aria-activedescendant');
        }
      };

      // Keyboard navigation
      const handleKeyDown = (e: KeyboardEvent) => {
        const visibleItems = items.filter((item) => !item.hidden);

        if (visibleItems.length === 0) return;

        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, visibleItems.length - 1);
            updateSelection();
            break;
          case 'ArrowUp':
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, 0);
            updateSelection();
            break;
          case 'Enter':
            e.preventDefault();
            if (selectedIndex >= 0 && visibleItems[selectedIndex]) {
              visibleItems[selectedIndex].click();
            }
            break;
          case 'Escape':
            if (input) input.blur();
            break;
        }
      };

      // Event listeners
      if (input) {
        input.addEventListener('input', filterItems);
        input.addEventListener('keydown', handleKeyDown);
      }

      // Item click handler
      items.forEach((item) => {
        item.addEventListener('click', () => {
          const value = item.getAttribute('data-value') || item.textContent;
          command.dispatchEvent(new CustomEvent('command-select', {
            detail: { value },
            bubbles: true
          }));
        });
      });
    });
  }

  initCommands();
  document.addEventListener('astro:page-load', initCommands);
</script>
